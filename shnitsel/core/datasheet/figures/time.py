from matplotlib.axes import Axes
from matplotlib.figure import Figure

from shnitsel.core.typedefs import PerState

from .common import figaxs_defaults, centertext
import xarray as xr


def plot_time_interstate_error(data: xr.DataArray, ax: Axes) -> Axes:
    """Function to plot the error bars/confidence intervals on time series interstate plots.

    Uses the `upper`, `lower` and `mean` variables of
    Args:
        data (DataArray): Interstate DataArray containing the `upper`, `lower` and `mean` variables generated by a confidence interval calculation.
        ax (Axes): Axes object to plot the graph to.

    Returns:
        Axes: The axes that have been plotted to
    """
    # TODO: FIXME: Support more states.
    vas = {
        '$S_2 - S_0$': 'bottom',
        '$S_2 - S_1$': 'bottom',
        '$S_1 - S_0$': 'top',
    }
    for sc, scdata in data.groupby('statecomb'):
        c = scdata['_color'].item()
        scdata = scdata.squeeze('statecomb')
        ax.fill_between('time', 'upper', 'lower', data=scdata, color=c, alpha=0.3)
        ax.plot('time', 'mean', data=scdata, c=c, lw=0.8)
        va = vas.get(sc, 'baseline')
        ax.text(scdata['time'][-1], scdata['mean'][-1], sc, c=c, va=va, ha='right')
    ylabel = data.attrs['tex']
    if u := data.attrs.get('units'):
        ylabel += f" / {u}"
    ax.set_ylabel(ylabel)
    return ax


def plot_populations_graph(pops: xr.DataArray, ax: Axes) -> Axes:
    """Plot a graph of populations to the provided axes.

    Args:
        pops (xr.DataArray): The per-state population DataArray.
        ax (Axes): The Axes object to plot the population graph into

    Returns:
        Axes: The resulting Axes object after the plot
    """
    # TODO: FIXME: Get state names from the dataset.
    for state, sdata in pops.groupby('state'):
        c = sdata['_color'].item()
        ax.plot(sdata['time'], sdata, c=c, lw=0.5)
        ax.text(
            float(sdata['time'][-1]), float(sdata[-1]), r"$S_%d$" % (state - 1), c=c
        )
    ax.set_ylabel('Population')
    return ax


@figaxs_defaults(mosaic=[['pop'], ['de'], ['ft']], scale_factors=(1 / 3, 1 / 2))
def plot_timeplots(
    pops: xr.DataArray,
    delta_E: xr.DataArray,
    fig: Figure,
    fosc_time: xr.DataArray | None = None,
    axs: dict[str, Axes] | None = None,
) -> dict[str, Axes]:
    """Function to generate all time plots, involving population plots and state-transition plots.

    Args:
        pops (xr.DataArray): DataArray containing state population data with a time coordinate
        delta_E (xr.DataArray): DataArray containing the energy delta per state combination.
        fosc_time (xr.DataArray, optional): The oscillation frequency in a DataArray groupable by `time`
        axs (dict[str, Axes], optional): The dictionary of named Axes objects to plot the inidividual graphs into. Defaults to None.
        fig (Figure, optional): A figure, consumed by the autmatic axes generation. Not used by the function itself. Defaults to None.

    Returns:
        dict[str, Axes]: The axes dictionary after plotting.
    """
    assert axs is not None, "Could not generate axes for time plots."
    plot_populations_graph(pops, axs['pop'])
    plot_time_interstate_error(delta_E, axs['de'])
    if fosc_time is not None:
        plot_time_interstate_error(fosc_time, axs['ft'])
        lowest_ax = axs['ft']
        higher_axnames = ['de', 'pop']
    else:
        centertext(r"No $\mathbf{\mu}_{ij}$ data", ax=axs['ft'])
        axs['ft'].get_yaxis().set_visible(False)
        axs['ft'].get_xaxis().set_visible(False)
        lowest_ax = axs['de']
        higher_axnames = ['pop']

    lowest_ax.set_xlabel(r'$t$ / fs')  # TODO
    lowest_ax.minorticks_on()

    for axn in higher_axnames:
        axs[axn].sharex(lowest_ax)
        axs[axn].tick_params(axis='x', labelbottom=False)

    return axs
